<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tensorflow Specialization Learning Note]]></title>
    <url>%2F2019%2F03%2F11%2Ftensorflow-specialization-learning-note%2F</url>
    <content type="text"><![CDATA[A learning note of the coursera specialization TensorFlow: From Basics to Mastery given by deeplearning.ai. Course 1: Introduction to TensorFlow for AI, ML and DL Coming soon … C1W1: A New Programming ParadigmNoteNew programming paradigm input output Triditional Programming Rules, Data Answers Machine Learning Answers, Data Rules CodeHow to fit a lineimport tensorflow as tf import numpy as np from tensorflow import keras model = tf.keras.Sequential([keras.layers.Dense(units=1, input_shape=[1])]) model.compile(optimizer=&#39;sgd&#39;, loss=&#39;mean_squared_error&#39;) xs = np.array([-1.0, 0.0, 1.0, 2.0, 3.0, 4.0], dtype=float) ys = np.array([-3.0, -1.0, 1.0, 3.0, 5.0, 7.0], dtype=float) model.fit(xs, ys, epochs=500) print(model.predict([10.0])) The predicted value is not 19.0 but aa little under. It is because neural networks deal with probabilities, so given the data that we fed the NN with, it calculated that there is a very high probability that the relationship between X and Y is Y=2X-1, but with only 6 data points we can’t know for sure. As a result, the result for 10 is very close to 19, but not necessarily 19. C1W2: Introduction to Computer VisionNoteWhy are the labels numbers instead of wordsUsing a number is a first step in avoiding bias — instead of labelling it with words in a specific language and excluding people who don’t speak that language! You can learn more about bias and techniques to avoid it here. What is cross entropy (CE)CE = - \sum_{i=0}^{C - 1} y_i \cdot log( f(\vec{x_i}) )where $C$: the number of classes $\vec{x_i}$: the feature vector of the example $i$ $y_i: the label of the example $i$ $f$: the learned prediction function which takes the feacture vector $\vec{x_i}$ and returns the probability of being class $y_i$ When $c = 2$ CE = - \big[ y_i \cdot log( p_i ) + (1 - y_i) \cdot log( 1 - p_i ) \big]Difference between categorical_crossentropy and sparse_categorical_crossentropy If your targets are one-hot encoded, use categorical_crossentropy.Examples of one-hot encodings:[1,0,0] [0,1,0] [0,0,1] But if your targets are integers, use sparse_categorical_crossentropy.Examples of integer encodings (for the sake of completion):1 2 3 Code# Early stopping class myCallback(tf.keras.callbacks.Callback): def on_epoch_end(self, epoch, logs={}): if(logs.get(&#39;loss&#39;)&lt;0.4): print(&quot;\nReached 60% accuracy so cancelling training!&quot;) self.model.stop_training = True callbacks = myCallback() mnist = tf.keras.datasets.fashion_mnist (training_images, training_labels), (test_images, test_labels) = mnist.load_data() # Data normalization training_images = training_images / 255.0 test_images = test_images / 255.0 model = tf.keras.models.Sequential([tf.keras.layers.Flatten(), tf.keras.layers.Dense(128, activation=tf.nn.relu), tf.keras.layers.Dense(10, activation=tf.nn.softmax)]) model.compile(optimizer = &#39;adam&#39;, loss = &#39;sparse_categorical_crossentropy&#39;, metrics=[&#39;accuracy&#39;]) model.fit(training_images, training_labels, epochs=5, callbacks=[callbacks]) model.evaluate(test_images, test_labels) C1W3: Enhancing Vision with Convolutional Neural NetworksNoteConvolution LayerEach kernal is an edge detector which is perfect for computer vision, because often it’s features that can get highlighted like this that distinguish one item for another, and the amount of information needed is then much less…because you’ll just train on the highlighted features. MaxPooling LayerThe convolution layer is followed by a MaxPooling layer which is then designed to compress the image, while maintaining the content of the features that were highlighted by the convlution Why CNN worksCNN tries different filters on the image and learning which ones work when looking at the training data. As a result, when it works, you’ll have greatly reduced information passing through the network, but because it isolates and identifies features, you can also get increased accuracy CodeModel# Reshape to a 4D tensor, otherwise the Convolutions do not recognize the shape training_images=training_images.reshape(60000, 28, 28, 1) training_images=training_images / 255.0 test_images = test_images.reshape(10000, 28, 28, 1) test_images=test_images/255.0 # 2-convolution-layer NN model = tf.keras.models.Sequential([ # default: strides = 1, padding = &#39;valid&#39; tf.keras.layers.Conv2D(64, (3,3), activation=&#39;relu&#39;, input_shape=(28, 28, 1)), # default: strides = None (same as pool_size), padding = &#39;valid&#39; tf.keras.layers.MaxPooling2D(2, 2), tf.keras.layers.Conv2D(64, (3,3), activation=&#39;relu&#39;), tf.keras.layers.MaxPooling2D(2,2), tf.keras.layers.Flatten(), tf.keras.layers.Dense(128, activation=&#39;relu&#39;), tf.keras.layers.Dense(10, activation=&#39;softmax&#39;) ]) _________________________________________________________________ || Layer (type) Output Shape Param # || Comments ================================================================= || conv2d (Conv2D) (None, 26, 26, 64) 640 || = 64 x (3 x 3 x 1 + 1) _________________________________________________________________ || max_pooling2d (MaxPooling2D) (None, 13, 13, 64) 0 || _________________________________________________________________ || conv2d_1 (Conv2D) (None, 11, 11, 64) 36928 || = 64 x (3 x 3 x 64 + 1) _________________________________________________________________ || max_pooling2d_1 (MaxPooling2 (None, 5, 5, 64) 0 || _________________________________________________________________ || flatten_1 (Flatten) (None, 1600) 0 || _________________________________________________________________ || dense_2 (Dense) (None, 128) 204928 || = 128 x (1600 + 1) _________________________________________________________________ || dense_3 (Dense) (None, 10) 1290 || = 10 * (128 + 1) ================================================================= || Total params: 243,786 Trainable params: 243,786 Non-trainable params: 0 How to compute output sizeConvolution layer (n + 2p - f + 1) \times (n + 2p - f + 1)MaxPooling layer Floor(\frac{height - f}{s} + 1) \times Floor(\frac{weight - f}{s} + 1) $n$: input size $p$: padding size $f$: filter size Two kinds of padding: Valid: no paddingp = 0 Same: results in padding the input such that the output has the same length as the original inputn + 2p - f + 1 = n \implies p = (f - 1) / 2where $f$ is almost always odd number How to compute number of parametersNF \times (f \times f \times NC_{input} + 1 ) $NF$: number of filters $NC_{input}$: number of input channels Each filter has a bias term Convolutions Over Volume Visualizing the Convolutions and Pooling Each row represents an itea. There are 3 shoes images here.The 4 columns represent the output of the first 4 layers (conv2d, max_pooling2d, conv2d_1, max_pooling2d_1).We can find the commonality for the same kind of items. C1W4: Using Real-world ImagesNoteImageGenerator ImageGenerator can flow images from a directory and perform operations such as resizing them on the fly. You can point it at a directory and then the sub-directories of that will automatically generate labels for you images |-- training | |-- horse | | |-- 1.jpg | | |-- 2.jpg | | `-- 3.jpg | `-- human | |-- 1.jpg | |-- 2.jpg | `-- 3.jpg `-- validation |-- horse | |-- 1.jpg | |-- 2.jpg | `-- 3.jpg `-- human |-- 1.jpg |-- 2.jpg `-- 3.jpg If you point ImageGenerator to training directory, it will generate a stream of images labelled with horse or human CodeModelimport tensorflow as tf from tensorflow.keras.optimizers import RMSprop model = tf.keras.models.Sequential([ # Note the input shape is the desired size of the image 300x300 with 3 bytes color # This is the first convolution tf.keras.layers.Conv2D(16, (3,3), activation=&#39;relu&#39;, input_shape=(300, 300, 3)), tf.keras.layers.MaxPooling2D(2, 2), # The second convolution tf.keras.layers.Conv2D(32, (3,3), activation=&#39;relu&#39;), tf.keras.layers.MaxPooling2D(2,2), # The third convolution tf.keras.layers.Conv2D(64, (3,3), activation=&#39;relu&#39;), tf.keras.layers.MaxPooling2D(2,2), # The fourth convolution tf.keras.layers.Conv2D(64, (3,3), activation=&#39;relu&#39;), tf.keras.layers.MaxPooling2D(2,2), # The fifth convolution tf.keras.layers.Conv2D(64, (3,3), activation=&#39;relu&#39;), tf.keras.layers.MaxPooling2D(2,2), # Flatten the results to feed into a DNN tf.keras.layers.Flatten(), # 512 neuron hidden layer tf.keras.layers.Dense(512, activation=&#39;relu&#39;), # Only 1 output neuron. It will contain a value from 0-1 where 0 for 1 class (&#39;horses&#39;) and 1 for the other (&#39;humans&#39;) tf.keras.layers.Dense(1, activation=&#39;sigmoid&#39;) ]) # Train our model with the binary_crossentropy loss, # because it&#39;s a binary classification problem and our final activation is a sigmoid. # More details: http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf model.compile(loss=&#39;binary_crossentropy&#39;, optimizer=RMSprop(lr=0.001), metrics=[&#39;acc&#39;]) model.summary() Layer (type) Output Shape Param # ================================================================= conv2d (Conv2D) (None, 298, 298, 16) 448 _________________________________________________________________ max_pooling2d (MaxPooling2D) (None, 149, 149, 16) 0 _________________________________________________________________ conv2d_1 (Conv2D) (None, 147, 147, 32) 4640 _________________________________________________________________ max_pooling2d_1 (MaxPooling2 (None, 73, 73, 32) 0 _________________________________________________________________ conv2d_2 (Conv2D) (None, 71, 71, 64) 18496 _________________________________________________________________ max_pooling2d_2 (MaxPooling2 (None, 35, 35, 64) 0 _________________________________________________________________ conv2d_3 (Conv2D) (None, 33, 33, 64) 36928 _________________________________________________________________ max_pooling2d_3 (MaxPooling2 (None, 16, 16, 64) 0 _________________________________________________________________ conv2d_4 (Conv2D) (None, 14, 14, 64) 36928 _________________________________________________________________ max_pooling2d_4 (MaxPooling2 (None, 7, 7, 64) 0 _________________________________________________________________ flatten (Flatten) (None, 3136) 0 _________________________________________________________________ dense (Dense) (None, 512) 1606144 _________________________________________________________________ dense_1 (Dense) (None, 1) 513 ================================================================= Total params: 1,704,097 Trainable params: 1,704,097 Non-trainable params: 0 The convolutions reduce the shape from 90000 (300 x 300) down to 3136 ImageDataGenerator# All images will be rescaled by 1./255 train_datagen = ImageDataGenerator(rescale=1/255) validation_datagen = ImageDataGenerator(rescale=1/255) # Flow training images in batches of 128 using train_datagen generator train_generator = train_datagen.flow_from_directory( &#39;/tmp/horse-or-human/&#39;, # This is the source directory for training images target_size=(300, 300), # All images will be resized to 150x150 batch_size=128, # Since we use binary_crossentropy loss, we need binary labels class_mode=&#39;binary&#39;) # Flow training images in batches of 128 using train_datagen generator validation_generator = validation_datagen.flow_from_directory( &#39;/tmp/validation-horse-or-human/&#39;, # This is the source directory for training images target_size=(300, 300), # All images will be resized to 150x150 batch_size=32, # Since we use binary_crossentropy loss, we need binary labels class_mode=&#39;binary&#39;) history = model.fit_generator( train_generator, steps_per_epoch=8, epochs=15, verbose=1, validation_data = validation_generator, validation_steps=8) Visualizing Intermediate Representations As you can see we go from the raw pixels of the images to increasingly abstract and compact representations. The representations downstream start highlighting what the network pays attention to, and they show fewer and fewer features being “activated”; most are set to zero. This is called “sparsity.” Representation sparsity is a key feature of deep learning. These representations carry increasingly less information about the original pixels of the image, but increasingly refined information about the class of the image. You can think of a convnet (or a deep network in general) as an information distillation pipeline.]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒜香蜂蜜鸡]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%92%9C%E9%A6%99%E8%9C%82%E8%9C%9C%E9%B8%A1%2F</url>
    <content type="text"><![CDATA[用时30分钟 原料四块鸡上腿肉盐胡椒四瓣蒜蜂蜜（2）米醋（1）酱油（1）大蒜粉（opt）白芝麻（opt）葱（opt） 做法 鸡肉洗干净，抹上盐，黑胡椒，大蒜粉，腌制10分钟 四瓣蒜 变成 蒜末 最好 蒜泥 热锅冷油 油少量（鸡皮出油）皮朝下放入鸡肉 每2分钟 翻面 共8分钟 锅中央放入蒜泥 蜂蜜 米醋 酱油 80毫升 水 火开大点 收汁 翻面 等汁浓稠 出锅（可以撒上 白芝麻 和 葱） 成品]]></content>
      <categories>
        <category>Cuisine</category>
      </categories>
      <tags>
        <tag>Plat</tag>
        <tag>Poulet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview Questions in 2018]]></title>
    <url>%2F2018%2F12%2F19%2Fintervew-questions-in-2018%2F</url>
    <content type="text"><![CDATA[A list of coding interview questions that I was asked in 2018. Question 1: Add BinaryStatement (leetcode: 791)Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = &quot;11&quot;, b = &quot;1&quot; Output: &quot;100&quot; Example 2: Input: a = &quot;1010&quot;, b = &quot;1011&quot; Output: &quot;10101&quot; SolutionString addBinary(String a, String b) { int i = a.length() - 1, j = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (i &gt;= 0 || j &gt;= 0) { int sum = carry; if (i &gt;= 0) { sum += a.charAt(i) - &#39;0&#39;; i--; } if (j &gt;= 0) { sum += b.charAt(j) - &#39;0&#39;; j--; } carry = sum / 2; sb.insert(0, sum % 2); } if (carry != 0) sb.insert(0, carry); return sb.toString(); } Complexity Comments Time O(n) / Space O(n) StringBuilder ExtentionWhat if the given strings can be numbers of any base ? String addBinary(String a, String b) { int i = a.length() - 1, j = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (i &gt;= 0 || j &gt;= 0) { int sum = carry; if (i &gt;= 0) { sum += a.charAt(i) - &#39;0&#39;; i--; } if (j &gt;= 0) { sum += b.charAt(j) - &#39;0&#39;; j--; } carry = sum / 2; sb.insert(0, sum % 2); } if (carry != 0) sb.insert(0, carry); return sb.toString(); } Question 2: cd commandStatementWrite a function to simluate linux command cd Example 1: Input: cur = &quot;/etc&quot;, path = &quot;/bin/&quot; Output: &quot;/bin&quot; Example 2: Input: a = &quot;/etc&quot;, b = &quot;hadoop&quot; Output: &quot;/etc/hadoop&quot; Example 3: Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;../../hive&quot; Output: &quot;/etc/hive&quot; Example 4: Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;.././conf&quot; Output: &quot;/etc/hadoop/conf&quot; SolutionString cd(String cur, String path) { if (path.startsWith(&quot;/&quot;)) return path; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String dir : cur.split(&quot;/&quot;)) if (!dir.isEmpty()) stack.push(dir); for (String dir : path.split(&quot;/&quot;)) if (dir.equals(&quot;..&quot;)) { if (!stack.isEmpty()) stack.pop(); } else if (!dir.equals(&quot;.&quot;)) { stack.push(dir); } String res = String.join(&quot;/&quot;, stack); return res.startsWith(&quot;/&quot;) ? res : &quot;/&quot; + res; } Complexity Comments Time O(n) / Space O(n) Stack Question 3: Custom Sort StringStatement (leetcode: 791)S and T are strings composed of lowercase letters. In S, no letter occurs more than once.S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.Return any permutation of T (as a string) that satisfies this property. Example : Input: S = &quot;cba&quot;, T = &quot;abcd&quot; Output: &quot;cbad&quot; Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. Note: S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only. Solutionpublic String customSortString(String S, String T) { int[] dict = new int[26]; for (char c : T.toCharArray()) { dict[c - &#39;a&#39;] += 1; } StringBuilder sb = new StringBuilder(); for (char c : S.toCharArray()) { for (int i = 0; i &lt; dict[c - &#39;a&#39;]; i++) sb.append(c); dict[c - &#39;a&#39;] = 0; } for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c++) for (int i = 0; i &lt; dict[c - &#39;a&#39;]; i++) sb.append(c); return sb.toString(); } Complexity Comments Time O(n) / Space O(n) StringBuilder Question 4: Position of the leftmost oneStatementGiven a binary matrix (containing only 0 and 1) of order n * n. All rows are sorted already. We need to find position of the left most 1.Note: in case of tie, return the position of the smallest row number. Example: Input matrix 0 1 1 1 0 0 1 1 1 1 1 1 // this row has maximum 1s 0 0 0 0 Output: [2, 0] Solutionint[] findPosition(int[][] matrix) { int r = matrix.length; if (r == 0) return null; int c = matrix[0].length; if (c == 0) return null; int[] res = new int[] {}; int j = c - 1; for (int i = 0; i &lt; r; i++) { while (j &gt;= 0 &amp;&amp; matrix[i][j] == 1) { j--; res = new int[] {i, j + 1}; } } return res; } Complexity Comments Time O(r + c) ends on the boundary Space O(1) / Question 5: Validate Binary Search TreeStatement (leetcode: 98)Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: Input: 2 / \ 1 3 Output: true Example 2: 5 / \ 1 4 / \ 3 6 Output: false Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value is 5 but its right child&#39;s value is 4. Solutionboolean validate(TreeNode node, long min, long max) { if (node == null) { return true; } else { if (node.val &gt; min &amp;&amp; node.val &lt; max) { return validate(node.left, min, node.val) &amp;&amp; validate(node.right, node.val, max); } else { return false; } } } boolean isValidBST(TreeNode root) { return validate(root, Long.MIN_VALUE, Long.MAX_VALUE); } Complexity Comments Time O(n) visit all the nodes Space O(log n) recursice call stack Question 6: Search word in the dictionaryStatement (leetcode: 211)Design a data structure that supports the following two operations: class WordDictionary { /** Initialize data structure */ public WordDictionary() /** Adds a word into the data structure. */ public void addWord(String word) /** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. */ public boolean search(String word) } void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example: addWord(&quot;bad&quot;) addWord(&quot;dad&quot;) addWord(&quot;mad&quot;) search(&quot;pad&quot;) -&gt; false search(&quot;bad&quot;) -&gt; true search(&quot;.ad&quot;) -&gt; true search(&quot;b..&quot;) -&gt; true Solutionclass WordDictionary { class TrieNode { TrieNode[] next = new TrieNode[26]; String word = null; } TrieNode root; public WordDictionary() { this.root = new TrieNode(); } /** Adds a word into the data structure. */ public void addWord(String word) { TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) { char c = word.charAt(i); if (node.next[c - &#39;a&#39;] == null) node.next[c - &#39;a&#39;] = new TrieNode(); node = node.next[c - &#39;a&#39;]; } node.word = word; } /** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. */ public boolean search(String word) { return match(word, 0, root); } private boolean match(String word, int i, TrieNode node) { if (i == word.length()) return node.word != null; char c = word.charAt(i); if (c == &#39;.&#39;) { for (TrieNode nextNode : node.next) { if (nextNode != null &amp;&amp; match(word, i + 1, nextNode)) { return true; } } return false; } else { TrieNode nextNode = node.next[c - &#39;a&#39;]; return nextNode != null &amp;&amp; match(word, i + 1, nextNode); } } } add Complexity Comments Time O(n) / Space O(n) node creation search Complexity Comments Time O(n) / Space O(n) recursive call stack Question 7: Valid PalindromeStatement (leetcode: 125)Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome. Example 1: Input: &quot;A man, a plan, a canal: Panama&quot; Output: true Example 2: Input: &quot;race a car&quot; Output: false Solutionboolean isValid(char c) { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;); } boolean isPalindrome(String s) { int i = 0; int j = s.length() - 1; while(i &lt;= j) { if (!isValid(s.charAt(i))) { i++; continue; } if (!isValid(s.charAt(j))) { j--; continue; } if (Character.toLowerCase(s.charAt(i)) == Character.toLowerCase(s.charAt(j))) { i++; j--; } else { return false; } } return true; } Complexity Comments Time O(n) / Space O(1) / Question 8: Shortest Distance To All StationsStatement Given a metro map of London, find the station which is closest to all the others stations. Solution (Floyd–Warshall algorithm)/** graph is a weighted undirected adjacency matrix */ int solve(double[][] graph) { int n = graph.length; double[][] dist = new double[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dist[i][j] = graph[i][j]; } } /** Floyd–Warshall algorithm */ for (int k = 0; k &lt; n; k++) { for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (dist[i][j] &gt; dist[i][k] + dist[k][j]) { dist[i][j] = dist[i][k] + dist[k][j]; } } } } double min = Integer.MAX_VALUE; int res = -1; for (int i = 0; i &lt; n; i++) { double sum = 0 for (double d : dist[i]) sum += d; if (sum &lt; min) { res = i; min = sum; } } return res; } Complexity Comments Time O(n ^ 3) / Space O(n ^ 2) / Question 9: Equilibrium PointStatement (leetcode: 724)Given an array of integers nums, write a method that returns the “pivot” index of this array.We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: Input: nums = [1, 7, 3, 6, 5, 6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs. Example 2: Input: nums = [1, 2, 3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. SolutionpivotIndex(int[] nums) { int sum = 0, leftsum = 0; for (int x: nums) sum += x; for (int i = 0; i &lt; nums.length; ++i) { if (leftsum == sum - leftsum - nums[i]) return i; leftsum += nums[i]; } return -1; } Complexity Comments Time O(n) / Space O(1) / Question 10: Complete Binary TreeStatementGiven a complete binary tree in which each node marked with a number in level order (root = 1) and several connections are removed.Find if the given number is still reachable from the root of the tree. Example 1: Input: tree = root, num = 5 1 -&gt; root / \ / \ / \ / \ / \ 2 3 / / \ / / \ 4 5 6 7 / \ / \ / \ / \ 8 9 10 11 12 13 14 15 Output: false Example 2: Input: tree = root, num = 6 1 -&gt; root \ \ \ \ \ 2 3 / \ / \ / \ / \ 4 5 6 7 / \ / \ / \ / \ 8 9 10 11 12 13 14 15 Output: true Solutionboolean findInCompleteTree(TreeNode root, int n) { List&lt;Boolean&gt; path = new LinkedList&lt;&gt;(); while (n &gt; 1) { if (n % 2 == 0) { path.add(0, true); } else { path.add(0, false); } n /= 2; } for (boolean p : path) { if (p) root = root.left; else root = root.right; if (root == null) return false; } return true; } Complexity Comments Time O(log n) / Space O(log n) / Extension (leetcode: 222)Count the number of node in a complete binary tree. Example 1: Input: tree = root 1 -&gt; root / \ / \ / \ / \ / \ 2 3 / \ / \ / \ / \ 4 5 6 7 / \ / \ / 8 9 10 11 12 Output: 12 int countInCompleteTree(TreeNode root) { TreeNode node = root; int depthLeft = 0; while (node != null) { depthLeft++; node = node.left; } node = root; int depthRight = 0; while (node != null) { depthRight++; node = node.right; } return depthLeft == depthRight ? (1 &lt;&lt; depthLeft) - 1 : 1 + countInCompleteTree(root.left) + countInCompleteTree(root.right); } Complexity Comments Time O(log n * log n) log n calls and each call takes log n to compute depth Space O(log n) recursive call stack Question 11: UTF-8 EncodingStatementA character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. This is how the UTF-8 encoding would work: Number of bytes Bits for code point First code point Last code point Byte 1 Byte 2 Byte 3 Byte 4 1 7 U+0000 U+007F 0xxxxxxx 2 11 U+0080 U+07FF 110xxxxx 10xxxxxx 3 16 U+0800 U+FFFF 1110xxxx 10xxxxxx 10xxxxxx 4 21 U+10000 U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given a byte array which contains only UTF-8 encoded characters and an integer limit,return the max number of bytes contains only valid UTF-8 encordings in the first limit bytes. Example 1: Input: stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx | 1110xxxx | 10xxxxxx | 10xxxxxx | 11110xxx | 10xxxxxx ||| 10xxxxxx | 10xxxxxx | limit = 8 Output: 5 Example 2: Input: stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx | limit = 5 Output: 2 Solutionint countUTF8Byte(byte[] stream, int limit) { if (stream.length &lt;= limit) { return stream.length; } else { while (limit &gt; 0 &amp;&amp; (stream[limit] &amp; 0xFF) &gt;&gt; 6 == 2) { limit--; } return limit; } } Complexity Comments Time O(1) No more than 6 bytes Space O(1) / Question 12: Design Rate limiterStatement (inspired by leetcode: 362)Design rate limiter API based on the count limit per minute and per hour.The granularity of timestamp is in second if needed. class RateLimiter { /** Initialize data structure */ public RateLimiter(long minuteCount, long hourCount) /** Return true if the function calls exceeded either minuteCount or hourCount, otherwise return false */ public boolean isLimited() } RateLimiter rl = new RateLimit(100, 6000); rl.isLimited() // return false; Solutionpublic class RateLimiter { class HitCounter { private int numBucket; private int[] time; private int[] hit; public HitCounter(int numBucket) { this.numBucket = numBucket; this.time = new int[numBucket]; this.hit = new int[numBucket]; } public void hit(int ts) { int bucket = ts % this.numBucket; if (time[bucket] == ts) { hit[bucket]++; } else { time[bucket] = ts; hit[bucket] = 1; } } public int count(int ts) { int cnt = 0; for (int i = 0; i &lt; this.numBucket; i++) { if (ts - time[i] &lt; this.numBucket) { cnt += hit[i]; } } return cnt; } } private long minuteLimit; private long hourLimit; private HitCounter minuteCounter; private HitCounter hourCounter; public RateLimiter(long minuteLimit, long hourLimit) { this.minuteLimit = minuteLimit; this.hourLimit = hourLimit; this.minuteCounter = new HitCounter(60); this.hourCounter = new HitCounter(3600); } public boolean isLimited() { int tsInSec = (int) (System.currentTimeMillis() / 1000); if (this.minuteCounter.count(tsInSec) &lt; this.minuteLimit &amp;&amp; this.hourCounter.count(tsInSec) &lt; this.hourLimit) { minuteCounter.hit(tsInSec); hourCounter.hit(tsInSec); return false; } else { return true; } } public static void main(String[] args) throws InterruptedException { RateLimiter rl = new RateLimiter(10, 600); int count = 0; while (true) { Thread.sleep(1000); if (rl.isLimited()) { break; } else { count++; System.out.println(&quot;Limit not reached: &quot; + count); } } System.out.println(&quot;Limit exceeded: &quot; + count); } } hit Complexity Comments Time O(1) / Space O(n) number of the buckets count Complexity Comments Time O(n) number of the buckets Space O(n) number of the buckets Question 13: Design Task Scheduler (cron)StatementImplement the following 3 methods. Start with scheduling part and then execution part. public class CronScheduler { void schedule(TimerTask task, long delay) {} void repeat(TimerTask t, long delay, long period) {} void daily(TimerTask t, long delay) {} } SolutionReference: java.util.Timer and java.util.TimerTask // TODO]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Coding</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
