<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Interview Questions in 2018]]></title>
    <url>%2F2018%2F12%2F19%2Fintervew-questions-in-2018%2F</url>
    <content type="text"><![CDATA[A list of coding interview questions that I was asked in 2018. Question 1: Add BinaryStatement (leetcode: 791)Given two binary strings, return their sum (also a binary string).The input strings are both non-empty and contains only characters 1 or 0. 123456789Example 1:Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot;Example 2:Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; Solution1234567891011121314151617181920String addBinary(String a, String b) &#123; int i = a.length() - 1, j = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (i &gt;= 0) &#123; sum += a.charAt(i) - '0'; i--; &#125; if (j &gt;= 0) &#123; sum += b.charAt(j) - '0'; j--; &#125; carry = sum / 2; sb.insert(0, sum % 2); &#125; if (carry != 0) sb.insert(0, carry); return sb.toString();&#125; Complexity Comments Time O(n) / Space O(n) StringBuilder ExtentionWhat if the given strings can be numbers of any base ? 1234567891011121314151617181920String addBinary(String a, String b) &#123; int i = a.length() - 1, j = b.length() - 1; int carry = 0; StringBuilder sb = new StringBuilder(); while (i &gt;= 0 || j &gt;= 0) &#123; int sum = carry; if (i &gt;= 0) &#123; sum += a.charAt(i) - '0'; i--; &#125; if (j &gt;= 0) &#123; sum += b.charAt(j) - '0'; j--; &#125; carry = sum / 2; sb.insert(0, sum % 2); &#125; if (carry != 0) sb.insert(0, carry); return sb.toString();&#125; Question 2: cd commandStatementWrite a function to simluate linux command cd 12345678910111213141516171819Example 1:Input: cur = &quot;/etc&quot;, path = &quot;/bin/&quot;Output: &quot;/bin&quot;Example 2:Input: a = &quot;/etc&quot;, b = &quot;hadoop&quot;Output: &quot;/etc/hadoop&quot;Example 3:Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;../../hive&quot;Output: &quot;/etc/hive&quot;Example 4:Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;.././conf&quot;Output: &quot;/etc/hadoop/conf&quot; Solution1234567891011121314151617String cd(String cur, String path) &#123; if (path.startsWith("/")) return path; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String dir : cur.split("/")) if (!dir.isEmpty()) stack.push(dir); for (String dir : path.split("/")) if (dir.equals("..")) &#123; if (!stack.isEmpty()) stack.pop(); &#125; else if (!dir.equals(".")) &#123; stack.push(dir); &#125; String res = String.join("/", stack); return res.startsWith("/") ? res : "/" + res;&#125; Complexity Comments Time O(n) / Space O(n) Stack Question 3: Custom Sort StringStatement (leetcode: 791)S and T are strings composed of lowercase letters. In S, no letter occurs more than once.S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the returned string.Return any permutation of T (as a string) that satisfies this property. 12345678Example :Input: S = &quot;cba&quot;, T = &quot;abcd&quot;Output: &quot;cbad&quot;Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs. Note: S has length at most 26, and no character is repeated in S. T has length at most 200. S and T consist of lowercase letters only. Solution12345678910111213141516171819public String customSortString(String S, String T) &#123; int[] dict = new int[26]; for (char c : T.toCharArray()) &#123; dict[c - 'a'] += 1; &#125; StringBuilder sb = new StringBuilder(); for (char c : S.toCharArray()) &#123; for (int i = 0; i &lt; dict[c - 'a']; i++) sb.append(c); dict[c - 'a'] = 0; &#125; for (char c = 'a'; c &lt;= 'z'; c++) for (int i = 0; i &lt; dict[c - 'a']; i++) sb.append(c); return sb.toString();&#125; Complexity Comments Time O(n) / Space O(n) StringBuilder Question 4: Position of the leftmost oneStatementGiven a binary matrix (containing only 0 and 1) of order n * n. All rows are sorted already. We need to find position of the left most 1.Note: in case of tie, return the position of the smallest row number. 123456789Example:Input matrix0 1 1 10 0 1 11 1 1 1 // this row has maximum 1s0 0 0 0Output: [2, 0] Solution12345678910111213141516int[] findPosition(int[][] matrix) &#123; int r = matrix.length; if (r == 0) return null; int c = matrix[0].length; if (c == 0) return null; int[] res = new int[] &#123;&#125;; int j = c - 1; for (int i = 0; i &lt; r; i++) &#123; while (j &gt;= 0 &amp;&amp; matrix[i][j] == 1) &#123; j--; res = new int[] &#123;i, j + 1&#125;; &#125; &#125; return res;&#125; Complexity Comments Time O(r + c) ends on the boundary Space O(1) / Question 5: Validate Binary Search TreeStatement (leetcode: 98)Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 123456789101112131415161718Example 1:Input: 2 / \ 1 3Output: trueExample 2: 5 / \ 1 4 / \ 3 6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&apos;s value is 5 but its right child&apos;s value is 4. Solution123456789101112131415boolean validate(TreeNode node, long min, long max) &#123; if (node == null) &#123; return true; &#125; else &#123; if (node.val &gt; min &amp;&amp; node.val &lt; max) &#123; return validate(node.left, min, node.val) &amp;&amp; validate(node.right, node.val, max); &#125; else &#123; return false; &#125; &#125;&#125;boolean isValidBST(TreeNode root) &#123; return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);&#125; Complexity Comments Time O(n) visit all the nodes Space O(log n) recursice call stack Question 6: Search word in the dictionaryStatement (leetcode: 211)Design a data structure that supports the following two operations: 1234567891011121314class WordDictionary &#123; /** Initialize data structure */ public WordDictionary() /** Adds a word into the data structure. */ public void addWord(String word) /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word)&#125;void addWord(word)bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. 12345678Example:addWord("bad")addWord("dad")addWord("mad")search("pad") -&gt; falsesearch("bad") -&gt; truesearch(".ad") -&gt; truesearch("b..") -&gt; true Solution123456789101112131415161718192021222324252627282930313233343536373839404142434445class WordDictionary &#123; class TrieNode &#123; TrieNode[] next = new TrieNode[26]; String word = null; &#125; TrieNode root; public WordDictionary() &#123; this.root = new TrieNode(); &#125; /** Adds a word into the data structure. */ public void addWord(String word) &#123; TrieNode node = root; for (int i = 0; i &lt; word.length(); i++) &#123; char c = word.charAt(i); if (node.next[c - 'a'] == null) node.next[c - 'a'] = new TrieNode(); node = node.next[c - 'a']; &#125; node.word = word; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ public boolean search(String word) &#123; return match(word, 0, root); &#125; private boolean match(String word, int i, TrieNode node) &#123; if (i == word.length()) return node.word != null; char c = word.charAt(i); if (c == '.') &#123; for (TrieNode nextNode : node.next) &#123; if (nextNode != null &amp;&amp; match(word, i + 1, nextNode)) &#123; return true; &#125; &#125; return false; &#125; else &#123; TrieNode nextNode = node.next[c - 'a']; return nextNode != null &amp;&amp; match(word, i + 1, nextNode); &#125; &#125;&#125; add Complexity Comments Time O(n) / Space O(n) node creation search Complexity Comments Time O(n) / Space O(n) recursive call stack Question 7: Valid PalindromeStatement (leetcode: 125)Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.Note: For the purpose of this problem, we define empty string as valid palindrome. 123456789Example 1:Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueExample 2:Input: &quot;race a car&quot;Output: false Solution12345678910111213141516171819202122232425boolean isValid(char c) &#123; return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= '0' &amp;&amp; c &lt;= '9');&#125;boolean isPalindrome(String s) &#123; int i = 0; int j = s.length() - 1; while(i &lt;= j) &#123; if (!isValid(s.charAt(i))) &#123; i++; continue; &#125; if (!isValid(s.charAt(j))) &#123; j--; continue; &#125; if (Character.toLowerCase(s.charAt(i)) == Character.toLowerCase(s.charAt(j))) &#123; i++; j--; &#125; else &#123; return false; &#125; &#125; return true;&#125; Complexity Comments Time O(n) / Space O(1) / Question 8: Shortest Distance To All StationsStatement Given a metro map of London, find the station which is closest to all the others stations. Solution (Floyd–Warshall algorithm)1234567891011121314151617181920212223242526272829303132333435/** graph is a weighted undirected adjacency matrix */int solve(double[][] graph) &#123; int n = graph.length; double[][] dist = new double[n][n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dist[i][j] = graph[i][j]; &#125; &#125; /** Floyd–Warshall algorithm */ for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dist[i][j] &gt; dist[i][k] + dist[k][j]) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125; double min = Integer.MAX_VALUE; int res = -1; for (int i = 0; i &lt; n; i++) &#123; double sum = 0 for (double d : dist[i]) sum += d; if (sum &lt; min) &#123; res = i; min = sum; &#125; &#125; return res;&#125; Complexity Comments Time O(n ^ 3) / Space O(n ^ 2) / Question 9: Equilibrium PointStatement (leetcode: 724)Given an array of integers nums, write a method that returns the “pivot” index of this array.We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. 12345678910111213141516Example 1:Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Example 2:Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement. Solution123456789pivotIndex(int[] nums) &#123; int sum = 0, leftsum = 0; for (int x: nums) sum += x; for (int i = 0; i &lt; nums.length; ++i) &#123; if (leftsum == sum - leftsum - nums[i]) return i; leftsum += nums[i]; &#125; return -1;&#125; Complexity Comments Time O(n) / Space O(1) / Question 10: Complete Binary TreeStatementGiven a complete binary tree in which each node marked with a number in level order (root = 1) and several connections are removed.Find if the given number is still reachable from the root of the tree. 123456789101112131415161718192021222324252627282930313233Example 1:Input: tree = root, num = 5 1 -&gt; root / \ / \ / \ / \ / \ 2 3 / / \ / / \ 4 5 6 7 / \ / \ / \ / \ 8 9 10 11 12 13 14 15Output: falseExample 2:Input: tree = root, num = 6 1 -&gt; root \ \ \ \ \ 2 3 / \ / \ / \ / \ 4 5 6 7 / \ / \ / \ / \ 8 9 10 11 12 13 14 15Output: true Solution1234567891011121314151617181920boolean findInCompleteTree(TreeNode root, int n) &#123; List&lt;Boolean&gt; path = new LinkedList&lt;&gt;(); while (n &gt; 1) &#123; if (n % 2 == 0) &#123; path.add(0, true); &#125; else &#123; path.add(0, false); &#125; n /= 2; &#125; for (boolean p : path) &#123; if (p) root = root.left; else root = root.right; if (root == null) return false; &#125; return true;&#125; Complexity Comments Time O(log n) / Space O(log n) / Extension (leetcode: 222)Count the number of node in a complete binary tree. 12345678910111213141516Example 1:Input: tree = root 1 -&gt; root / \ / \ / \ / \ / \ 2 3 / \ / \ / \ / \ 4 5 6 7 / \ / \ / 8 9 10 11 12Output: 12 12345678910111213141516171819int countInCompleteTree(TreeNode root) &#123; TreeNode node = root; int depthLeft = 0; while (node != null) &#123; depthLeft++; node = node.left; &#125; node = root; int depthRight = 0; while (node != null) &#123; depthRight++; node = node.right; &#125; return depthLeft == depthRight ? (1 &lt;&lt; depthLeft) - 1 : 1 + countInCompleteTree(root.left) + countInCompleteTree(root.right);&#125; Complexity Comments Time O(log n * log n) log n calls and each call takes log n to compute depth Space O(log n) recursive call stack Question 11: UTF-8 EncodingStatementA character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules: For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. This is how the UTF-8 encoding would work: Number of bytes Bits for code point First code point Last code point Byte 1 Byte 2 Byte 3 Byte 4 1 7 U+0000 U+007F 0xxxxxxx 2 11 U+0080 U+07FF 110xxxxx 10xxxxxx 3 16 U+0800 U+FFFF 1110xxxx 10xxxxxx 10xxxxxx 4 21 U+10000 U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx Given a byte array which contains only UTF-8 encoded characters and an integer limit,return the max number of bytes contains only valid UTF-8 encordings in the first limit bytes. 123456789101112131415Example 1:Input:stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx | 1110xxxx | 10xxxxxx | 10xxxxxx | 11110xxx | 10xxxxxx ||| 10xxxxxx | 10xxxxxx |limit = 8Output: 5Example 2:Input:stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx |limit = 5Output: 2 Solution12345678910int countUTF8Byte(byte[] stream, int limit) &#123; if (stream.length &lt;= limit) &#123; return stream.length; &#125; else &#123; while (limit &gt; 0 &amp;&amp; (stream[limit] &amp; 0xFF) &gt;&gt; 6 == 2) &#123; limit--; &#125; return limit; &#125;&#125; Complexity Comments Time O(1) No more than 6 bytes Space O(1) / Question 12: Design Rate limiterStatement (inspired by leetcode: 362)Design rate limiter API based on the count limit per minute and per hour.The granularity of timestamp is in second if needed. 1234567891011class RateLimiter &#123; /** Initialize data structure */ public RateLimiter(long minuteCount, long hourCount) /** Return true if the function calls exceeded either minuteCount or hourCount, otherwise return false */ public boolean isLimited() &#125;RateLimiter rl = new RateLimit(100, 6000);rl.isLimited() // return false; Solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class RateLimiter &#123; class HitCounter &#123; private int numBucket; private int[] time; private int[] hit; public HitCounter(int numBucket) &#123; this.numBucket = numBucket; this.time = new int[numBucket]; this.hit = new int[numBucket]; &#125; public void hit(int ts) &#123; int bucket = ts % this.numBucket; if (time[bucket] == ts) &#123; hit[bucket]++; &#125; else &#123; time[bucket] = ts; hit[bucket] = 1; &#125; &#125; public int count(int ts) &#123; int cnt = 0; for (int i = 0; i &lt; this.numBucket; i++) &#123; if (ts - time[i] &lt; this.numBucket) &#123; cnt += hit[i]; &#125; &#125; return cnt; &#125; &#125; private long minuteLimit; private long hourLimit; private HitCounter minuteCounter; private HitCounter hourCounter; public RateLimiter(long minuteLimit, long hourLimit) &#123; this.minuteLimit = minuteLimit; this.hourLimit = hourLimit; this.minuteCounter = new HitCounter(60); this.hourCounter = new HitCounter(3600); &#125; public boolean isLimited() &#123; int tsInSec = (int) (System.currentTimeMillis() / 1000); if (this.minuteCounter.count(tsInSec) &lt; this.minuteLimit &amp;&amp; this.hourCounter.count(tsInSec) &lt; this.hourLimit) &#123; minuteCounter.hit(tsInSec); hourCounter.hit(tsInSec); return false; &#125; else &#123; return true; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; RateLimiter rl = new RateLimiter(10, 600); int count = 0; while (true) &#123; Thread.sleep(1000); if (rl.isLimited()) &#123; break; &#125; else &#123; count++; System.out.println("Limit not reached: " + count); &#125; &#125; System.out.println("Limit exceeded: " + count); &#125;&#125; hit Complexity Comments Time O(1) / Space O(n) number of the buckets count Complexity Comments Time O(n) number of the buckets Space O(n) number of the buckets Question 13: Design Task Scheduler (cron)StatementImplement the following 3 methods. Start with scheduling part and then execution part. 12345public class CronScheduler &#123; void schedule(TimerTask task, long delay) &#123;&#125; void repeat(TimerTask t, long delay, long period) &#123;&#125; void daily(TimerTask t, long delay) &#123;&#125;&#125; SolutionReference: java.util.Timer and java.util.TimerTask 1// TODO]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
</search>
