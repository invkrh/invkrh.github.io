<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yorozuya</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://invkrh.me/"/>
  <updated>2019-02-22T12:04:02.858Z</updated>
  <id>http://invkrh.me/</id>
  
  <author>
    <name>Hao Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Interview Questions in 2018</title>
    <link href="http://invkrh.me/2018/12/19/intervew-questions-in-2018/"/>
    <id>http://invkrh.me/2018/12/19/intervew-questions-in-2018/</id>
    <published>2018-12-18T23:00:00.000Z</published>
    <updated>2019-02-22T12:04:02.858Z</updated>
    
    <content type="html"><![CDATA[<p>A list of coding interview questions that I was asked in 2018.</p><a id="more"></a><h2 id="Question-1-Add-Binary"><a href="#Question-1-Add-Binary" class="headerlink" title="Question 1: Add Binary"></a>Question 1: Add Binary</h2><h3 id="Statement-leetcode-791"><a href="#Statement-leetcode-791" class="headerlink" title="Statement (leetcode: 791)"></a>Statement (leetcode: 791)</h3><p>Given two binary strings, return their sum (also a binary string).<br>The input strings are both non-empty and contains only characters 1 or 0.</p><pre><code>Example 1:Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot;Example 2:Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">String addBinary(String a, String b) {    int i = a.length() - 1, j = b.length() - 1;    int carry = 0;    StringBuilder sb = new StringBuilder();    while (i &gt;= 0 || j &gt;= 0) {        int sum = carry;        if (i &gt;= 0) {            sum += a.charAt(i) - &#39;0&#39;;            i--;        }        if (j &gt;= 0) {            sum += b.charAt(j) - &#39;0&#39;;            j--;        }        carry = sum / 2;        sb.insert(0, sum % 2);    }    if (carry != 0) sb.insert(0, carry);    return sb.toString();}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>StringBuilder</td></tr></tbody></table></div><h3 id="Extention"><a href="#Extention" class="headerlink" title="Extention"></a>Extention</h3><p>What if the given strings can be numbers of any base ?</p><pre><code class="lang-java">String addBinary(String a, String b) {    int i = a.length() - 1, j = b.length() - 1;    int carry = 0;    StringBuilder sb = new StringBuilder();    while (i &gt;= 0 || j &gt;= 0) {        int sum = carry;        if (i &gt;= 0) {            sum += a.charAt(i) - &#39;0&#39;;            i--;        }        if (j &gt;= 0) {            sum += b.charAt(j) - &#39;0&#39;;            j--;        }        carry = sum / 2;        sb.insert(0, sum % 2);    }    if (carry != 0) sb.insert(0, carry);    return sb.toString();}</code></pre><h2 id="Question-2-cd-command"><a href="#Question-2-cd-command" class="headerlink" title="Question 2: cd command"></a>Question 2: <code>cd</code> command</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>Write a function to simluate linux command <code>cd</code></p><pre><code>Example 1:Input: cur = &quot;/etc&quot;, path = &quot;/bin/&quot;Output: &quot;/bin&quot;Example 2:Input: a = &quot;/etc&quot;, b = &quot;hadoop&quot;Output: &quot;/etc/hadoop&quot;Example 3:Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;../../hive&quot;Output: &quot;/etc/hive&quot;Example 4:Input: a = &quot;/etc/hadoop/conf&quot;, b = &quot;.././conf&quot;Output: &quot;/etc/hadoop/conf&quot;</code></pre><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">String cd(String cur, String path) {    if (path.startsWith(&quot;/&quot;)) return path;    Stack&lt;String&gt; stack = new Stack&lt;&gt;();    for (String dir : cur.split(&quot;/&quot;))        if (!dir.isEmpty()) stack.push(dir);    for (String dir : path.split(&quot;/&quot;))        if (dir.equals(&quot;..&quot;)) {            if (!stack.isEmpty()) stack.pop();        } else if (!dir.equals(&quot;.&quot;)) {            stack.push(dir);        }    String res = String.join(&quot;/&quot;, stack);    return res.startsWith(&quot;/&quot;) ? res : &quot;/&quot; + res;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>Stack</td></tr></tbody></table></div><h2 id="Question-3-Custom-Sort-String"><a href="#Question-3-Custom-Sort-String" class="headerlink" title="Question 3: Custom Sort String"></a>Question 3: Custom Sort String</h2><h3 id="Statement-leetcode-791-1"><a href="#Statement-leetcode-791-1" class="headerlink" title="Statement (leetcode: 791)"></a>Statement (leetcode: 791)</h3><p><code>S</code> and <code>T</code> are strings composed of lowercase letters. In <code>S</code>, no letter occurs more than once.<br><code>S</code> was sorted in some custom order previously. We want to permute the characters of <code>T</code> so that they match the order that <code>S</code> was sorted. More specifically, if <code>x</code> occurs before <code>y</code> in <code>S</code>, then <code>x</code> should occur before <code>y</code> in the returned string.<br>Return any permutation of <code>T</code> (as a string) that satisfies this property.</p><pre><code>Example :Input: S = &quot;cba&quot;, T = &quot;abcd&quot;Output: &quot;cbad&quot;Explanation: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; appear in S, so the order of &quot;a&quot;, &quot;b&quot;, &quot;c&quot; should be &quot;c&quot;, &quot;b&quot;, and &quot;a&quot;. Since &quot;d&quot; does not appear in S, it can be at any position in T. &quot;dcba&quot;, &quot;cdba&quot;, &quot;cbda&quot; are also valid outputs.</code></pre><p>Note:</p><ul><li>S has length at most 26, and no character is repeated in S.</li><li>T has length at most 200.</li><li>S and T consist of lowercase letters only.</li></ul><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">public String customSortString(String S, String T) {    int[] dict = new int[26];    for (char c : T.toCharArray()) {        dict[c - &#39;a&#39;] += 1;    }    StringBuilder sb = new StringBuilder();    for (char c : S.toCharArray()) {        for (int i = 0; i &lt; dict[c - &#39;a&#39;]; i++)            sb.append(c);        dict[c - &#39;a&#39;] = 0;    }    for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c++)        for (int i = 0; i &lt; dict[c - &#39;a&#39;]; i++)            sb.append(c);    return sb.toString();}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>StringBuilder</td></tr></tbody></table></div><h2 id="Question-4-Position-of-the-leftmost-one"><a href="#Question-4-Position-of-the-leftmost-one" class="headerlink" title="Question 4: Position of the leftmost one"></a>Question 4: Position of the leftmost one</h2><h3 id="Statement-1"><a href="#Statement-1" class="headerlink" title="Statement"></a>Statement</h3><p>Given a binary matrix (containing only 0 and 1) of order <code>n * n</code>. All rows are sorted already. We need to find position of the left most 1.<br>Note: in case of tie, return the position of the smallest row number.</p><pre><code>Example:Input matrix0 1 1 10 0 1 11 1 1 1  // this row has maximum 1s0 0 0 0Output: [2, 0]</code></pre><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">int[] findPosition(int[][] matrix) {    int r = matrix.length;    if (r == 0) return null;    int c = matrix[0].length;    if (c == 0) return null;    int[] res = new int[] {};    int j = c - 1;    for (int i = 0; i &lt; r; i++) {        while (j &gt;= 0 &amp;&amp; matrix[i][j] == 1) {            j--;            res = new int[] {i, j + 1};        }    }    return res;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(r + c)</td><td>ends on the boundary</td></tr><tr><td>Space</td><td>O(1)</td><td>/</td></tr></tbody></table></div><h2 id="Question-5-Validate-Binary-Search-Tree"><a href="#Question-5-Validate-Binary-Search-Tree" class="headerlink" title="Question 5: Validate Binary Search Tree"></a>Question 5: Validate Binary Search Tree</h2><h3 id="Statement-leetcode-98"><a href="#Statement-leetcode-98" class="headerlink" title="Statement (leetcode: 98)"></a>Statement (leetcode: 98)</h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><pre><code>Example 1:Input:    2   / \  1   3Output: trueExample 2:    5   / \  1   4     / \    3   6Output: falseExplanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value             is 5 but its right child&#39;s value is 4.</code></pre><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">boolean validate(TreeNode node, long min, long max) {    if (node == null) {        return true;    } else {        if (node.val &gt; min &amp;&amp; node.val &lt; max) {            return validate(node.left, min, node.val) &amp;&amp; validate(node.right, node.val, max);        } else {            return false;        }    }}boolean isValidBST(TreeNode root) {    return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>visit all the nodes</td></tr><tr><td>Space</td><td>O(log n)</td><td>recursice call stack</td></tr></tbody></table></div><h2 id="Question-6-Search-word-in-the-dictionary"><a href="#Question-6-Search-word-in-the-dictionary" class="headerlink" title="Question 6: Search word in the dictionary"></a>Question 6: Search word in the dictionary</h2><h3 id="Statement-leetcode-211"><a href="#Statement-leetcode-211" class="headerlink" title="Statement (leetcode: 211)"></a>Statement (leetcode: 211)</h3><p>Design a data structure that supports the following two operations:</p><pre><code class="lang-java">class WordDictionary {    /** Initialize data structure */    public WordDictionary()    /** Adds a word into the data structure. */    public void addWord(String word)    /** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. */    public boolean search(String word)}void addWord(word)bool search(word)</code></pre><p><code>search(word)</code> can search a literal word or a regular expression string containing only letters a-z or <code>.</code>. A <code>.</code> means it can represent any one letter.</p><pre><code class="lang-java">Example:addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true</code></pre><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">class WordDictionary {    class TrieNode {        TrieNode[] next = new TrieNode[26];        String word = null;    }    TrieNode root;    public WordDictionary() {        this.root = new TrieNode();    }    /** Adds a word into the data structure. */    public void addWord(String word) {        TrieNode node = root;        for (int i = 0; i &lt; word.length(); i++) {            char c = word.charAt(i);            if (node.next[c - &#39;a&#39;] == null) node.next[c - &#39;a&#39;] = new TrieNode();            node = node.next[c - &#39;a&#39;];        }        node.word = word;    }    /** Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter. */    public boolean search(String word) {        return match(word, 0, root);    }    private boolean match(String word, int i, TrieNode node) {        if (i == word.length()) return node.word != null;        char c = word.charAt(i);        if (c == &#39;.&#39;) {            for (TrieNode nextNode : node.next) {                if (nextNode != null &amp;&amp; match(word, i + 1, nextNode)) {                    return true;                }            }            return false;        } else {            TrieNode nextNode = node.next[c - &#39;a&#39;];            return nextNode != null &amp;&amp; match(word, i + 1, nextNode);        }    }}</code></pre><div class="table-container"><table><thead><tr><th>add</th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>node creation</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>search</th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>recursive call stack</td></tr></tbody></table></div><h2 id="Question-7-Valid-Palindrome"><a href="#Question-7-Valid-Palindrome" class="headerlink" title="Question 7: Valid Palindrome"></a>Question 7: Valid Palindrome</h2><h3 id="Statement-leetcode-125"><a href="#Statement-leetcode-125" class="headerlink" title="Statement (leetcode: 125)"></a>Statement (leetcode: 125)</h3><p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.<br>Note: For the purpose of this problem, we define empty string as valid palindrome.</p><pre><code>Example 1:Input: &quot;A man, a plan, a canal: Panama&quot;Output: trueExample 2:Input: &quot;race a car&quot;Output: false</code></pre><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">boolean isValid(char c) {    return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);}boolean isPalindrome(String s) {    int i = 0;    int j = s.length() - 1;    while(i &lt;= j) {        if (!isValid(s.charAt(i))) {            i++;            continue;        }        if (!isValid(s.charAt(j))) {            j--;            continue;        }        if (Character.toLowerCase(s.charAt(i)) == Character.toLowerCase(s.charAt(j))) {            i++;            j--;        } else {            return false;        }    }    return true;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(1)</td><td>/</td></tr></tbody></table></div><h2 id="Question-8-Shortest-Distance-To-All-Stations"><a href="#Question-8-Shortest-Distance-To-All-Stations" class="headerlink" title="Question 8: Shortest Distance To All Stations"></a>Question 8: Shortest Distance To All Stations</h2><h3 id="Statement-2"><a href="#Statement-2" class="headerlink" title="Statement"></a>Statement</h3><img src="/2018/12/19/intervew-questions-in-2018/tube-map.gif" title="London Tube Map"><p>Given a metro map of London, find the station which is closest to all the others stations.</p><h3 id="Solution-Floyd–Warshall-algorithm"><a href="#Solution-Floyd–Warshall-algorithm" class="headerlink" title="Solution (Floyd–Warshall algorithm)"></a>Solution (Floyd–Warshall algorithm)</h3><pre><code class="lang-java">/** graph is a weighted undirected adjacency matrix */int solve(double[][] graph) {    int n = graph.length;    double[][] dist = new double[n][n];    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {                dist[i][j] = graph[i][j];            }        }    /** Floyd–Warshall algorithm */    for (int k = 0; k &lt; n; k++) {        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; n; j++) {                if (dist[i][j] &gt; dist[i][k] + dist[k][j]) {                    dist[i][j] = dist[i][k] + dist[k][j];                }            }        }    }    double min = Integer.MAX_VALUE;    int res = -1;    for (int i = 0; i &lt; n; i++) {        double sum = 0        for (double d : dist[i])            sum += d;        if (sum &lt; min) {            res = i;            min = sum;        }    }    return res;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n ^ 3)</td><td>/</td></tr><tr><td>Space</td><td>O(n ^ 2)</td><td>/</td></tr></tbody></table></div><h2 id="Question-9-Equilibrium-Point"><a href="#Question-9-Equilibrium-Point" class="headerlink" title="Question 9: Equilibrium Point"></a>Question 9: Equilibrium Point</h2><h3 id="Statement-leetcode-724"><a href="#Statement-leetcode-724" class="headerlink" title="Statement (leetcode: 724)"></a>Statement (leetcode: 724)</h3><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.<br>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.<br>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p><pre><code>Example 1:Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Example 2:Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement.</code></pre><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">pivotIndex(int[] nums) {    int sum = 0, leftsum = 0;    for (int x: nums) sum += x;    for (int i = 0; i &lt; nums.length; ++i) {        if (leftsum == sum - leftsum - nums[i]) return i;        leftsum += nums[i];    }    return -1;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>/</td></tr><tr><td>Space</td><td>O(1)</td><td>/</td></tr></tbody></table></div><h2 id="Question-10-Complete-Binary-Tree"><a href="#Question-10-Complete-Binary-Tree" class="headerlink" title="Question 10: Complete Binary Tree"></a>Question 10: Complete Binary Tree</h2><h3 id="Statement-3"><a href="#Statement-3" class="headerlink" title="Statement"></a>Statement</h3><p>Given a complete binary tree in which each node marked with a number in level order (root = 1) and several connections are removed.<br>Find if the given number is still reachable from the root of the tree.</p><pre><code>Example 1:Input: tree = root, num = 5            1 -&gt; root           / \          /   \         /     \        /       \       /         \      2           3     /           / \    /           /   \   4     5     6     7  / \   / \   / \   / \ 8   9 10 11 12 13 14 15Output: falseExample 2:Input: tree = root, num = 6            1 -&gt; root             \              \               \                \                 \      2           3     / \         / \    /   \       /   \   4     5     6     7  / \   / \   / \   / \ 8   9 10 11 12 13 14 15Output: true</code></pre><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">boolean findInCompleteTree(TreeNode root, int n) {    List&lt;Boolean&gt; path = new LinkedList&lt;&gt;();    while (n &gt; 1) {        if (n % 2 == 0) {            path.add(0, true);        } else {            path.add(0, false);        }        n /= 2;    }    for (boolean p : path) {        if (p) root = root.left;        else root = root.right;        if (root == null) return false;    }    return true;}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(log n)</td><td>/</td></tr><tr><td>Space</td><td>O(log n)</td><td>/</td></tr></tbody></table></div><h3 id="Extension-leetcode-222"><a href="#Extension-leetcode-222" class="headerlink" title="Extension (leetcode: 222)"></a>Extension (leetcode: 222)</h3><p>Count the number of node in a complete binary tree.</p><pre><code>Example 1:Input: tree = root            1 -&gt; root           / \          /   \         /     \        /       \       /         \      2           3     / \         / \    /   \       /   \   4     5     6     7  / \   / \   / 8   9 10 11 12Output: 12</code></pre><pre><code class="lang-java">int countInCompleteTree(TreeNode root) {    TreeNode node = root;    int depthLeft = 0;    while (node != null) {        depthLeft++;        node = node.left;    }    node = root;    int depthRight = 0;    while (node != null) {        depthRight++;        node = node.right;    }    return depthLeft == depthRight ?        (1 &lt;&lt; depthLeft) - 1 :        1 + countInCompleteTree(root.left) + countInCompleteTree(root.right);}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(log n * log n)</td><td>log n calls and each call takes log n to compute depth</td></tr><tr><td>Space</td><td>O(log n)</td><td>recursive call stack</td></tr></tbody></table></div><h2 id="Question-11-UTF-8-Encoding"><a href="#Question-11-UTF-8-Encoding" class="headerlink" title="Question 11: UTF-8 Encoding"></a>Question 11: UTF-8 Encoding</h2><h3 id="Statement-4"><a href="#Statement-4" class="headerlink" title="Statement"></a>Statement</h3><p>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:</p><ul><li>For 1-byte character, the first bit is a 0, followed by its unicode code.</li><li>For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.</li></ul><p>This is how the UTF-8 encoding would work:    </p><div class="table-container"><table><thead><tr><th>Number of bytes</th><th>Bits for code point</th><th>First code point</th><th>Last code point</th><th>Byte 1</th><th>Byte 2</th><th>Byte 3</th><th>Byte 4</th></tr></thead><tbody><tr><td>1</td><td>7</td><td>U+0000</td><td>U+007F</td><td>0xxxxxxx</td><td></td><td></td><td></td></tr><tr><td>2</td><td>11</td><td>U+0080</td><td>U+07FF</td><td>110xxxxx</td><td>10xxxxxx</td><td></td><td></td></tr><tr><td>3</td><td>16</td><td>U+0800</td><td>U+FFFF</td><td>1110xxxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td></td></tr><tr><td>4</td><td>21</td><td>U+10000</td><td>U+10FFFF</td><td>11110xxx</td><td>10xxxxxx</td><td>10xxxxxx</td><td>10xxxxxx</td></tr></tbody></table></div><p>Given a byte array which contains only UTF-8 encoded characters and an integer <code>limit</code>,<br>return the max number of bytes contains only valid UTF-8 encordings in the first <code>limit</code> bytes.</p><pre><code>Example 1:Input:stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx | 1110xxxx | 10xxxxxx | 10xxxxxx | 11110xxx | 10xxxxxx ||| 10xxxxxx | 10xxxxxx |limit = 8Output: 5Example 2:Input:stream = | 0xxxxxxx | 110xxxxx | 10xxxxxx |limit = 5Output: 2</code></pre><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">int countUTF8Byte(byte[] stream, int limit) {    if (stream.length &lt;= limit) {        return stream.length;    } else {        while (limit &gt; 0 &amp;&amp; (stream[limit] &amp; 0xFF) &gt;&gt; 6 == 2) {            limit--;        }        return limit;    }}</code></pre><div class="table-container"><table><thead><tr><th></th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(1)</td><td>No more than 6 bytes</td></tr><tr><td>Space</td><td>O(1)</td><td>/</td></tr></tbody></table></div><h2 id="Question-12-Design-Rate-limiter"><a href="#Question-12-Design-Rate-limiter" class="headerlink" title="Question 12: Design Rate limiter"></a>Question 12: Design Rate limiter</h2><h3 id="Statement-inspired-by-leetcode-362"><a href="#Statement-inspired-by-leetcode-362" class="headerlink" title="Statement (inspired by leetcode: 362)"></a>Statement (inspired by leetcode: 362)</h3><p>Design rate limiter API based on the count limit per minute and per hour.<br>The granularity of timestamp is in second if needed.</p><pre><code class="lang-java">class RateLimiter {    /** Initialize data structure */    public RateLimiter(long minuteCount, long hourCount)    /** Return true if the function calls exceeded either minuteCount or hourCount, otherwise return false */    public boolean isLimited() }RateLimiter rl = new RateLimit(100, 6000);rl.isLimited() // return false;</code></pre><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><pre><code class="lang-java">public class RateLimiter {    class HitCounter {        private int   numBucket;        private int[] time;        private int[] hit;        public HitCounter(int numBucket) {            this.numBucket = numBucket;            this.time = new int[numBucket];            this.hit = new int[numBucket];        }        public void hit(int ts) {            int bucket = ts % this.numBucket;            if (time[bucket] == ts) {                hit[bucket]++;            } else {                time[bucket] = ts;                hit[bucket] = 1;            }        }        public int count(int ts) {            int cnt = 0;            for (int i = 0; i &lt; this.numBucket; i++) {                if (ts - time[i] &lt; this.numBucket) {                    cnt += hit[i];                }            }            return cnt;        }    }    private long       minuteLimit;    private long       hourLimit;    private HitCounter minuteCounter;    private HitCounter hourCounter;    public RateLimiter(long minuteLimit, long hourLimit) {        this.minuteLimit = minuteLimit;        this.hourLimit = hourLimit;        this.minuteCounter = new HitCounter(60);        this.hourCounter = new HitCounter(3600);    }    public boolean isLimited() {        int tsInSec = (int) (System.currentTimeMillis() / 1000);        if (this.minuteCounter.count(tsInSec) &lt; this.minuteLimit &amp;&amp;            this.hourCounter.count(tsInSec) &lt; this.hourLimit) {            minuteCounter.hit(tsInSec);            hourCounter.hit(tsInSec);            return false;        } else {            return true;        }    }    public static void main(String[] args) throws InterruptedException {        RateLimiter rl = new RateLimiter(10, 600);        int count = 0;        while (true) {            Thread.sleep(1000);            if (rl.isLimited()) {                break;            } else {                count++;                System.out.println(&quot;Limit not reached: &quot; + count);            }        }        System.out.println(&quot;Limit exceeded: &quot; + count);    }}</code></pre><div class="table-container"><table><thead><tr><th>hit</th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(1)</td><td>/</td></tr><tr><td>Space</td><td>O(n)</td><td>number of the buckets</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>count</th><th>Complexity</th><th>Comments</th></tr></thead><tbody><tr><td>Time</td><td>O(n)</td><td>number of the buckets</td></tr><tr><td>Space</td><td>O(n)</td><td>number of the buckets</td></tr></tbody></table></div><h2 id="Question-13-Design-Task-Scheduler-cron"><a href="#Question-13-Design-Task-Scheduler-cron" class="headerlink" title="Question 13: Design Task Scheduler (cron)"></a>Question 13: Design Task Scheduler (<code>cron</code>)</h2><h3 id="Statement-5"><a href="#Statement-5" class="headerlink" title="Statement"></a>Statement</h3><p>Implement the following 3 methods. Start with scheduling part and then execution part.</p><pre><code class="lang-java">public class CronScheduler {    void schedule(TimerTask task, long delay) {}    void repeat(TimerTask t, long delay, long period) {}    void daily(TimerTask t, long delay) {}}</code></pre><h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h3><p>Reference: <code>java.util.Timer</code> and <code>java.util.TimerTask</code></p><pre><code class="lang-java">// TODO</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;A list of coding interview questions that I was asked in 2018.&lt;/p&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://invkrh.me/categories/Interview/"/>
    
    
      <category term="Algorithm" scheme="http://invkrh.me/tags/Algorithm/"/>
    
      <category term="Coding" scheme="http://invkrh.me/tags/Coding/"/>
    
  </entry>
  
</feed>
